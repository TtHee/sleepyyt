<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SleepyYT">
    <meta name="theme-color" content="#0f172a">
    <title>SleepyYT</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- NoSleep.js - Prevent screen from sleeping -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: '#0f172a',
                        darker: '#020617',
                        accent: '#fb923c'
                    }
                }
            }
        }
    </script>

    <style>
        /* iOS Safe Area */
        body {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        /* Custom scrollbar for dark theme */
        ::-webkit-scrollbar {
            width: 4px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a;
        }
        ::-webkit-scrollbar-thumb {
            background: #fb923c;
            border-radius: 2px;
        }

        /* Player container - smaller preview size */
        .player-wrapper {
            position: relative;
            padding-bottom: 35%;
            height: 0;
            overflow: hidden;
            border-radius: 8px;
        }
        .player-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        /* Input styling */
        input[type="number"],
        input[type="text"] {
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Touch feedback */
        .touch-btn:active {
            transform: scale(0.97);
            transition: transform 0.1s;
        }
    </style>
</head>
<body class="bg-dark min-h-screen text-white font-sans">
    <div class="max-w-lg mx-auto px-4 py-4">

        <!-- Header + Timer Combined -->
        <header class="text-center mb-4">
            <h1 class="text-xl font-bold text-accent flex items-center justify-center gap-2">
                <span>ğŸŒ™</span>
                <span>SleepyYT</span>
            </h1>
        </header>

        <!-- Timer Display (inline style) -->
        <div id="timerDisplay" class="hidden mb-4">
            <div class="bg-darker rounded-xl p-4 border border-slate-800">
                <div class="flex items-center justify-between mb-3">
                    <p class="text-slate-400 text-xs">å‰©é¤˜æ™‚é–“</p>
                    <p id="timerCountdown" class="text-3xl font-mono font-bold text-accent">
                        00:00
                    </p>
                </div>
                <div class="flex gap-2">
                    <button
                        id="pauseTimerBtn"
                        class="flex-1 py-2 bg-yellow-500/20 text-yellow-400 rounded-lg text-sm touch-btn"
                    >
                        â¸ï¸ æš«åœ
                    </button>
                    <button
                        id="stopTimerBtn"
                        class="flex-1 py-2 bg-red-500/20 text-red-400 rounded-lg text-sm touch-btn"
                    >
                        â¹ï¸ åœæ­¢
                    </button>
                </div>
            </div>
        </div>

        <!-- YouTube Player (smaller preview) -->
        <div class="mb-4">
            <div class="player-wrapper bg-darker border border-slate-800">
                <div id="player"></div>
            </div>
        </div>

        <!-- Status Indicator -->
        <div id="statusBar" class="mb-4 text-center">
            <span id="statusText" class="text-slate-500 text-sm">
                ç­‰å¾…è¨­å®š...
            </span>
        </div>

        <!-- Debug Log (moved to top for visibility) -->
        <div id="debugPanel" class="mb-4 bg-red-900/30 rounded-xl p-3 border border-red-800">
            <div class="flex justify-between items-center mb-2">
                <span class="text-red-400 text-xs font-bold">ğŸ” é™¤éŒ¯æ—¥èªŒ</span>
                <div class="flex gap-2">
                    <button id="copyDebugBtn" class="text-xs text-green-400 px-2 py-1 bg-green-500/20 rounded">ğŸ“‹ è¤‡è£½</button>
                    <button id="clearDebugBtn" class="text-xs text-red-400 px-2 py-1 bg-red-500/20 rounded">æ¸…é™¤</button>
                </div>
            </div>
            <div id="debugLog" class="text-xs text-yellow-300 font-mono h-24 overflow-y-auto whitespace-pre-wrap break-all bg-black/30 p-2 rounded"></div>
        </div>

        <!-- Settings Panel -->
        <div class="bg-darker rounded-xl p-4 border border-slate-800 mb-4">

            <!-- YouTube URL -->
            <div class="mb-4">
                <label class="block text-slate-400 text-sm mb-2">
                    YouTube ç¶²å€
                </label>
                <div class="flex gap-2">
                    <input
                        type="text"
                        id="youtubeUrl"
                        placeholder="è²¼ä¸Šå½±ç‰‡æˆ–æ’­æ”¾æ¸…å–®ç¶²å€"
                        value="https://youtube.com/playlist?list=PLTHJiIfg_SmSh939efM9kNbmyJS6z21e3&si=Igdw9lnb68DJRmtd"
                        class="flex-1 bg-dark border border-slate-700 rounded-xl px-4 py-3 text-white placeholder-slate-600 focus:outline-none focus:border-accent transition-colors text-sm"
                    >
                    <button
                        id="clearUrlBtn"
                        class="px-3 bg-slate-700 text-slate-400 rounded-xl text-sm touch-btn"
                    >
                        æ¸…é™¤
                    </button>
                </div>
            </div>

            <!-- Skip Settings Row -->
            <div class="grid grid-cols-2 gap-3 mb-4">
                <div>
                    <label class="block text-slate-400 text-xs mb-1">
                        è·³éç‰‡é ­ (ç§’)
                    </label>
                    <input
                        type="number"
                        id="skipStart"
                        value="90"
                        min="0"
                        max="600"
                        class="w-full bg-dark border border-slate-700 rounded-lg px-3 py-2 text-white text-center focus:outline-none focus:border-accent transition-colors"
                    >
                </div>
                <div>
                    <label class="block text-slate-400 text-xs mb-1">
                        è·³éç‰‡å°¾ (ç§’)
                    </label>
                    <input
                        type="number"
                        id="skipEnd"
                        value="50"
                        min="0"
                        max="600"
                        class="w-full bg-dark border border-slate-700 rounded-lg px-3 py-2 text-white text-center focus:outline-none focus:border-accent transition-colors"
                    >
                </div>
            </div>

            <!-- Start Index -->
            <div class="mb-4">
                <label class="block text-slate-400 text-xs mb-1">
                    å¾ç¬¬å¹¾é›†é–‹å§‹
                </label>
                <input
                    type="number"
                    id="startIndex"
                    value="1"
                    min="1"
                    max="999"
                    class="w-full bg-dark border border-slate-700 rounded-lg px-3 py-2 text-white text-center focus:outline-none focus:border-accent transition-colors"
                >
            </div>

            <!-- Sleep Timer -->
            <div class="mb-4">
                <label class="block text-slate-400 text-xs mb-1">
                    ç¡çœ å®šæ™‚ (åˆ†é˜)
                </label>
                <div class="flex items-center gap-2">
                    <button
                        class="time-btn w-10 h-10 bg-dark border border-slate-700 rounded-lg text-lg touch-btn"
                        data-adjust="-10"
                    >âˆ’</button>
                    <input
                        type="number"
                        id="totalMins"
                        value="40"
                        min="5"
                        max="180"
                        class="flex-1 bg-dark border border-slate-700 rounded-lg px-3 py-2 text-white text-center text-lg font-semibold focus:outline-none focus:border-accent transition-colors"
                    >
                    <button
                        class="time-btn w-10 h-10 bg-dark border border-slate-700 rounded-lg text-lg touch-btn"
                        data-adjust="10"
                    >+</button>
                </div>
            </div>

            <!-- Quick Time Buttons -->
            <div class="flex gap-2">
                <button class="quick-time flex-1 py-2 bg-dark border border-slate-700 rounded-lg text-sm text-slate-400 touch-btn" data-mins="20">20åˆ†</button>
                <button class="quick-time flex-1 py-2 bg-dark border border-slate-700 rounded-lg text-sm text-slate-400 touch-btn" data-mins="40">40åˆ†</button>
                <button class="quick-time flex-1 py-2 bg-dark border border-slate-700 rounded-lg text-sm text-slate-400 touch-btn" data-mins="60">60åˆ†</button>
                <button class="quick-time flex-1 py-2 bg-dark border border-slate-700 rounded-lg text-sm text-slate-400 touch-btn" data-mins="90">90åˆ†</button>
            </div>
        </div>

        <!-- Action Button -->
        <button
            id="startBtn"
            class="w-full py-4 bg-accent text-dark font-bold text-lg rounded-xl touch-btn shadow-lg shadow-accent/20"
        >
            ğŸµ é–‹å§‹æ’­æ”¾
        </button>

        <!-- Footer Tips -->
        <footer class="mt-4 text-center">
            <p class="text-slate-600 text-xs">
                ğŸ’¡ è«‹å°‡æ­¤ç¶²é ã€ŒåŠ å…¥ä¸»ç•«é¢ã€ä¸¦ä¿æŒè¢å¹•é–‹å•Ÿä»¥ç¢ºä¿èƒŒæ™¯æ’­æ”¾
            </p>
        </footer>

    </div>

    <!-- YouTube IFrame API -->
    <script>
        // ============================
        // SleepyYT - Main Application
        // ============================

        // Global variables
        let player = null;
        let progressCheckerId = null;
        let countdownInterval = null;
        let playbackWatchdogId = null;
        let remainingSeconds = 0;
        let isPlaying = false;
        let noSleep = null;
        let lastPlayingTime = 0;

        // Debug logging for mobile - persisted to localStorage
        function debugLog(msg) {
            const time = new Date().toLocaleTimeString('zh-TW');
            const logLine = `[${time}] ${msg}`;

            // Save to localStorage for persistence across page reloads
            try {
                let logs = JSON.parse(localStorage.getItem('sleepyyt_debug') || '[]');
                logs.unshift(logLine);
                if (logs.length > 50) logs = logs.slice(0, 50);
                localStorage.setItem('sleepyyt_debug', JSON.stringify(logs));

                // Update display
                const logEl = document.getElementById('debugLog');
                if (logEl) {
                    logEl.textContent = logs.join('\n');
                }
            } catch (e) {
                console.warn('Debug log error:', e);
            }
            console.log(msg);
        }

        // Load persisted logs on page load
        function loadDebugLogs() {
            try {
                const logs = JSON.parse(localStorage.getItem('sleepyyt_debug') || '[]');
                const logEl = document.getElementById('debugLog');
                if (logEl && logs.length > 0) {
                    logEl.textContent = logs.join('\n');
                }
            } catch (e) {}
        }

        // Detect page reload - will be logged after DOM is ready
        // (moved to DOMContentLoaded handler)

        // Session state for recovery - also saved to localStorage
        let sessionActive = false;
        let lastParsedUrl = null;
        let lastStartIndex = 0;
        let lastSkipStart = 0;

        // ç·©è¡å¤±æ•—è¨ˆæ•¸å™¨
        let bufferFailCount = 0;
        let lastBufferTime = 0;

        // ä½¿ç”¨è€…ä¸»å‹•æš«åœæ¨™è¨˜ï¼ˆé˜²æ­¢è‡ªå‹•æ¢å¾©ï¼‰
        let userPaused = false;

        // Save session to localStorage for recovery
        function saveSession() {
            try {
                const session = {
                    active: sessionActive,
                    parsedUrl: lastParsedUrl,
                    startIndex: lastStartIndex,
                    skipStart: lastSkipStart,
                    remaining: remainingSeconds,
                    savedAt: Date.now()
                };
                localStorage.setItem('sleepyyt_session', JSON.stringify(session));
            } catch (e) {}
        }

        // Restore session from localStorage
        function restoreSession() {
            try {
                const saved = localStorage.getItem('sleepyyt_session');
                if (saved) {
                    const session = JSON.parse(saved);
                    // Only restore if saved within last 5 minutes
                    if (Date.now() - session.savedAt < 5 * 60 * 1000 && session.active && session.remaining > 0) {
                        debugLog('ğŸ”§ å¾ localStorage æ¢å¾© session: å‰©é¤˜=' + session.remaining + 's');
                        sessionActive = session.active;
                        lastParsedUrl = session.parsedUrl;
                        lastStartIndex = session.startIndex;
                        lastSkipStart = session.skipStart;
                        remainingSeconds = session.remaining;
                        return true;
                    }
                }
            } catch (e) {}
            return false;
        }

        // Clear saved session
        function clearSession() {
            try {
                localStorage.removeItem('sleepyyt_session');
            } catch (e) {}
        }

        // Initialize NoSleep
        try {
            noSleep = new NoSleep();
        } catch (e) {
            console.warn('NoSleep not available:', e);
        }

        // DOM Elements
        const elements = {
            youtubeUrl: document.getElementById('youtubeUrl'),
            clearUrlBtn: document.getElementById('clearUrlBtn'),
            skipStart: document.getElementById('skipStart'),
            skipEnd: document.getElementById('skipEnd'),
            startIndex: document.getElementById('startIndex'),
            totalMins: document.getElementById('totalMins'),
            startBtn: document.getElementById('startBtn'),
            pauseTimerBtn: document.getElementById('pauseTimerBtn'),
            stopTimerBtn: document.getElementById('stopTimerBtn'),
            timerDisplay: document.getElementById('timerDisplay'),
            timerCountdown: document.getElementById('timerCountdown'),
            statusText: document.getElementById('statusText')
        };

        // Timer state
        let timerPaused = false;

        // ============================
        // URL Parsing Function
        // ============================

        function parseYouTubeUrl(url) {
            if (!url) return null;

            url = url.trim();

            // Result object
            let result = {
                type: null,      // 'video' or 'playlist'
                videoId: null,
                playlistId: null
            };

            // Check for playlist ID
            const playlistMatch = url.match(/[?&]list=([^&]+)/);
            if (playlistMatch) {
                result.playlistId = playlistMatch[1];
                result.type = 'playlist';
            }

            // Check for video ID in various formats
            const videoPatterns = [
                /youtu\.be\/([^?&]+)/,                    // youtu.be/xxxxx
                /youtube\.com\/watch\?v=([^&]+)/,         // youtube.com/watch?v=xxxxx
                /youtube\.com\/embed\/([^?&]+)/,          // youtube.com/embed/xxxxx
                /youtube\.com\/v\/([^?&]+)/,              // youtube.com/v/xxxxx
                /youtube\.com\/shorts\/([^?&]+)/,         // youtube.com/shorts/xxxxx
            ];

            for (const pattern of videoPatterns) {
                const match = url.match(pattern);
                if (match) {
                    result.videoId = match[1];
                    if (!result.type) {
                        result.type = 'video';
                    }
                    break;
                }
            }

            // If still no match, check if it's a raw ID
            if (!result.type && /^[A-Za-z0-9_-]{11}$/.test(url)) {
                result.videoId = url;
                result.type = 'video';
            }

            return result.type ? result : null;
        }

        // ============================
        // LocalStorage Functions
        // ============================

        function saveSettings() {
            const settings = {
                youtubeUrl: elements.youtubeUrl.value,
                skipStart: elements.skipStart.value,
                skipEnd: elements.skipEnd.value,
                startIndex: elements.startIndex.value,
                totalMins: elements.totalMins.value
            };
            localStorage.setItem('sleepyyt_settings', JSON.stringify(settings));
        }

        const DEFAULT_URL = 'https://youtube.com/playlist?list=PLTHJiIfg_SmSh939efM9kNbmyJS6z21e3&si=Igdw9lnb68DJRmtd';

        function loadSettings() {
            try {
                const saved = localStorage.getItem('sleepyyt_settings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    elements.youtubeUrl.value = settings.youtubeUrl || DEFAULT_URL;
                    elements.skipStart.value = settings.skipStart || 90;
                    elements.skipEnd.value = settings.skipEnd || 50;
                    elements.startIndex.value = settings.startIndex || 1;
                    elements.totalMins.value = settings.totalMins || 40;
                }
            } catch (e) {
                console.warn('Failed to load settings:', e);
            }
        }

        // ============================
        // NoSleep (Keep Screen Awake)
        // ============================

        function enableNoSleep() {
            if (noSleep) {
                noSleep.enable();
                console.log('NoSleep enabled - screen will stay awake');
            }
        }

        function disableNoSleep() {
            if (noSleep) {
                try {
                    noSleep.disable();
                    // Re-create NoSleep instance to ensure clean state
                    noSleep = new NoSleep();
                    console.log('NoSleep disabled - screen can now sleep');
                } catch (e) {
                    console.warn('Error disabling NoSleep:', e);
                }
            }
        }

        // ============================
        // YouTube Player Setup
        // ============================

        // è¿½è¹¤ API åˆå§‹åŒ–æ¬¡æ•¸
        let apiInitCount = 0;
        let playerRecoveryInProgress = false;

        function onYouTubeIframeAPIReady() {
            apiInitCount++;
            debugLog('ğŸ¥ YouTube API åˆå§‹åŒ– #' + apiInitCount);

            // å¦‚æœæ’­æ”¾å™¨å·²å­˜åœ¨ä¸”æ­£åœ¨æ’­æ”¾ï¼Œä¸è¦é‡å»º
            if (player && typeof player.getPlayerState === 'function') {
                try {
                    const state = player.getPlayerState();
                    if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.BUFFERING) {
                        debugLog('âš ï¸ æ’­æ”¾å™¨å·²å­˜åœ¨ä¸”é‹ä½œä¸­ï¼Œè·³éé‡å»º');
                        return;
                    }
                } catch (e) {
                    // æ’­æ”¾å™¨å¯èƒ½å·²æå£ï¼Œç¹¼çºŒé‡å»º
                }
            }

            player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'playsinline': 1,
                    'rel': 0,
                    'modestbranding': 1,
                    'fs': 0,
                    'controls': 1,
                    'enablejsapi': 1,
                    'autoplay': 1  // iOS éœ€è¦ autoplay é…åˆ mute æ‰èƒ½è‡ªå‹•æ’­æ”¾
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            debugLog('ğŸ¬ æ’­æ”¾å™¨å°±ç·’ session=' + sessionActive + ' å‰©é¤˜=' + remainingSeconds + ' recovery=' + playerRecoveryInProgress);

            // å¦‚æœæ­£åœ¨æ¢å¾©ä¸­ï¼Œè·³éé‡è¤‡è™•ç†
            if (playerRecoveryInProgress) {
                debugLog('âš ï¸ æ¢å¾©å·²åœ¨é€²è¡Œä¸­ï¼Œè·³é');
                return;
            }

            // å˜—è©¦å¾ localStorage æ¢å¾© session
            if (!sessionActive && remainingSeconds === 0) {
                const restored = restoreSession();
                if (restored) {
                    debugLog('âœ… Session å·²å¾ localStorage æ¢å¾©');
                }
            }

            // Check if we have an active countdown (more reliable than sessionActive)
            const hasActiveTimer = countdownInterval !== null && remainingSeconds > 0;

            // If we had an active session, try to recover it
            if ((sessionActive || hasActiveTimer) && remainingSeconds > 0 && lastParsedUrl) {
                playerRecoveryInProgress = true;
                debugLog('ğŸ”„ å˜—è©¦æ¢å¾©æ’­æ”¾...');
                sessionActive = true; // Ensure sessionActive is set
                updateStatus('æ¢å¾©æ’­æ”¾ä¸­...');

                // å¦‚æœè¨ˆæ™‚å™¨æ²’åœ¨é‹è¡Œï¼Œé‡æ–°å•Ÿå‹•
                if (!countdownInterval) {
                    debugLog('â±ï¸ é‡æ–°å•Ÿå‹•è¨ˆæ™‚å™¨ï¼Œå‰©é¤˜=' + remainingSeconds + 's');
                    // é¡¯ç¤ºè¨ˆæ™‚å™¨ UI
                    elements.timerDisplay.classList.remove('hidden');
                    elements.pauseTimerBtn.textContent = 'â¸ï¸ æš«åœ';
                    updateCountdownDisplay();

                    // é‡æ–°å•Ÿå‹•è¨ˆæ™‚å™¨ï¼ˆä¸é‡ç½®æ™‚é–“ï¼‰
                    lastTimerTick = Date.now();
                    countdownInterval = setInterval(() => {
                        if (!timerPaused) {
                            const now = Date.now();
                            const elapsed = Math.floor((now - lastTimerTick) / 1000);
                            if (elapsed > 2) {
                                debugLog('âš ï¸ è¨ˆæ™‚å™¨æ¼‚ç§»: ' + elapsed + 'ç§’');
                                remainingSeconds -= elapsed;
                            } else {
                                remainingSeconds--;
                            }
                            lastTimerTick = now;
                            updateCountdownDisplay();
                            if (remainingSeconds % 5 === 0) {
                                saveSession();
                            }
                            if (remainingSeconds <= 0) {
                                stopEverything('timer_expired');
                            }
                        }
                    }, 1000);

                    // é‡æ–°å•Ÿå‹• watchdog
                    startPlaybackWatchdog();
                }

                // Re-start playback with longer delay to let player stabilize
                setTimeout(() => {
                    try {
                        // iOS Safari éœ€è¦å…ˆéœéŸ³æ‰èƒ½è‡ªå‹•æ’­æ”¾
                        // å…ˆéœéŸ³ï¼Œè¼‰å…¥å¾Œå†å˜—è©¦å–æ¶ˆéœéŸ³
                        if (player.mute) {
                            player.mute();
                            debugLog('ğŸ”‡ å…ˆéœéŸ³ä»¥å…è¨±è‡ªå‹•æ’­æ”¾');
                        }

                        if (lastParsedUrl.type === 'playlist') {
                            player.loadPlaylist({
                                list: lastParsedUrl.playlistId,
                                listType: 'playlist',
                                index: lastStartIndex,
                                startSeconds: lastSkipStart
                            });
                        } else if (lastParsedUrl.videoId) {
                            player.loadVideoById({
                                videoId: lastParsedUrl.videoId,
                                startSeconds: lastSkipStart
                            });
                        }

                        // ç­‰å½±ç‰‡é–‹å§‹æ’­æ”¾å¾Œå–æ¶ˆéœéŸ³
                        setTimeout(() => {
                            if (player && player.unMute && player.getPlayerState) {
                                const state = player.getPlayerState();
                                if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.BUFFERING) {
                                    player.unMute();
                                    debugLog('ğŸ”Š å–æ¶ˆéœéŸ³');
                                }
                            }
                            playerRecoveryInProgress = false;
                        }, 3000);
                    } catch (e) {
                        console.error('Recovery failed:', e);
                        debugLog('âŒ æ¢å¾©å¤±æ•—: ' + e.message);
                        updateStatus('æ¢å¾©å¤±æ•—');
                        playerRecoveryInProgress = false;
                    }
                }, 1000);
            } else if (!hasActiveTimer) {
                updateStatus('æ’­æ”¾å™¨å·²å°±ç·’');
            }
        }

        function onPlayerStateChange(event) {
            // YT.PlayerState: UNSTARTED=-1, ENDED=0, PLAYING=1, PAUSED=2, BUFFERING=3, CUED=5
            const stateNames = {'-1':'æœªé–‹å§‹', '0':'çµæŸ', '1':'æ’­æ”¾ä¸­', '2':'æš«åœ', '3':'ç·©è¡', '5':'å·²è¼‰å…¥'};
            debugLog('ğŸ“º ç‹€æ…‹è®Šæ›´: ' + (stateNames[event.data] || event.data));

            if (event.data === YT.PlayerState.PLAYING) {
                isPlaying = true;
                bufferFailCount = 0; // é‡ç½®ç·©è¡å¤±æ•—è¨ˆæ•¸
                handleVideoStart();
                startProgressChecker();

                // åªæœ‰åœ¨è¨ˆæ™‚å™¨é‚„æ²’å•Ÿå‹•æ™‚æ‰å•Ÿå‹•ï¼ˆç­‰ç·©è¡å®Œæˆå¾Œæ‰é–‹å§‹å€’æ•¸ï¼‰
                if (!countdownInterval && sessionActive) {
                    startSleepTimer();
                    debugLog('â±ï¸ ç·©è¡å®Œæˆï¼Œè¨ˆæ™‚å™¨å•Ÿå‹•');
                }
                updateStatus('æ’­æ”¾ä¸­...');
            } else if (event.data === YT.PlayerState.PAUSED) {
                // Only update status, don't stop progress checker immediately
                // This prevents issues with brief pauses (buffering, etc.)
                updateStatus('å·²æš«åœ');
            } else if (event.data === YT.PlayerState.ENDED) {
                console.log('Video ended, checking for next...');
                // Check if there's a next video in playlist
                try {
                    const playlist = player.getPlaylist();
                    const currentIndex = player.getPlaylistIndex();

                    if (playlist && playlist.length > 0) {
                        if (currentIndex < playlist.length - 1) {
                            // There's a next video, let YouTube auto-advance
                            updateStatus('ä¸‹ä¸€é¦–...');
                        } else {
                            // Last video in playlist, loop back to first
                            updateStatus('æ’­æ”¾æ¸…å–®çµæŸï¼Œå¾é ­é–‹å§‹...');
                            const skipStart = parseInt(elements.skipStart.value) || 0;
                            player.playVideoAt(0);
                            if (skipStart > 0) {
                                setTimeout(() => player.seekTo(skipStart, true), 500);
                            }
                        }
                    } else {
                        // Single video ended
                        updateStatus('å½±ç‰‡çµæŸ');
                    }
                } catch (e) {
                    console.warn('Error handling video end:', e);
                }
            } else if (event.data === YT.PlayerState.BUFFERING) {
                const now = Date.now();
                // å¦‚æœè·é›¢ä¸Šæ¬¡ç·©è¡ä¸åˆ° 30 ç§’ï¼Œè¨ˆæ•¸
                if (now - lastBufferTime < 30000) {
                    bufferFailCount++;
                    debugLog('â³ ç·©è¡ä¸­... (é€£çºŒç¬¬ ' + bufferFailCount + ' æ¬¡)');

                    // å¦‚æœé€£çºŒç·©è¡è¶…é 8 æ¬¡ï¼ˆç´„ 2 åˆ†é˜ï¼‰ï¼Œå˜—è©¦è·³åˆ°ä¸‹ä¸€å€‹å½±ç‰‡
                    if (bufferFailCount >= 8 && lastParsedUrl && lastParsedUrl.type === 'playlist') {
                        debugLog('âš ï¸ ç·©è¡å¤šæ¬¡å¤±æ•—ï¼Œå˜—è©¦ä¸‹ä¸€é¦–...');
                        bufferFailCount = 0;
                        setTimeout(() => {
                            if (player && player.nextVideo) {
                                player.nextVideo();
                            }
                        }, 2000);
                    }
                } else {
                    bufferFailCount = 1;
                    debugLog('â³ ç·©è¡ä¸­...');
                }
                lastBufferTime = now;
                updateStatus('ç·©è¡ä¸­... è«‹ç¨å€™');
            } else if (event.data === YT.PlayerState.UNSTARTED) {
                // Video is unstarted, might need to trigger play
                console.log('Video unstarted');
            } else if (event.data === YT.PlayerState.CUED) {
                // Video is cued but not playing, start it
                console.log('Video cued, attempting to play...');
                setTimeout(() => {
                    if (player && player.playVideo && remainingSeconds > 0) {
                        player.playVideo();
                    }
                }, 500);
            }
        }

        function onPlayerError(event) {
            console.error('Player error:', event.data);
            updateStatus('æ’­æ”¾éŒ¯èª¤ï¼Œå˜—è©¦ä¸‹ä¸€é¦–...');
            setTimeout(() => {
                if (player && player.nextVideo) {
                    player.nextVideo();
                }
            }, 1000);
        }

        // ============================
        // Playback Control Logic
        // ============================

        function handleVideoStart() {
            const skipStart = parseInt(elements.skipStart.value) || 0;

            if (skipStart > 0) {
                const currentTime = player.getCurrentTime();
                if (currentTime < skipStart) {
                    player.seekTo(skipStart, true);
                    updateStatus(`å·²è·³éç‰‡é ­ ${skipStart} ç§’`);
                }
            }

            // Save current playlist index (convert 0-based to 1-based for user)
            saveCurrentProgress();
        }

        function saveCurrentProgress() {
            try {
                const currentIndex = player.getPlaylistIndex();
                if (currentIndex >= 0) {
                    // Save as 1-based index for user display
                    elements.startIndex.value = currentIndex + 1;
                    saveSettings();
                }
            } catch (e) {
                // Ignore errors for single video
            }
        }

        function startProgressChecker() {
            stopProgressChecker();

            progressCheckerId = setInterval(() => {
                if (!player) return;

                try {
                    const playerState = player.getPlayerState();

                    // Check if player is actually playing (state 1)
                    if (playerState !== YT.PlayerState.PLAYING) {
                        // å¦‚æœä½¿ç”¨è€…æŒ‰äº†æš«åœï¼Œä¸è¦è‡ªå‹•æ¢å¾©
                        // åªæœ‰åœ¨ sessionActive ä¸”éæš«åœç‹€æ…‹ä¸‹æ‰å˜—è©¦æ¢å¾©
                        // ç§»é™¤è‡ªå‹•æ¢å¾©é‚è¼¯ï¼Œè®“ watchdog è™•ç†
                        return;
                    }

                    const duration = player.getDuration();
                    const currentTime = player.getCurrentTime();
                    const skipEnd = parseInt(elements.skipEnd.value) || 0;

                    if (duration > 0 && skipEnd > 0) {
                        const timeRemaining = duration - currentTime;
                        if (timeRemaining <= skipEnd && timeRemaining > 0) {
                            // Check if there's a next video in playlist
                            const playlist = player.getPlaylist();
                            const currentIndex = player.getPlaylistIndex();

                            if (playlist && playlist.length > 0 && currentIndex < playlist.length - 1) {
                                // Has next video, skip to it
                                updateStatus('è·³éç‰‡å°¾ï¼Œä¸‹ä¸€é¦–...');
                                player.nextVideo();
                            } else if (playlist && playlist.length > 0 && currentIndex === playlist.length - 1) {
                                // Last video, loop back to first
                                updateStatus('æ’­æ”¾æ¸…å–®çµæŸï¼Œå¾é ­é–‹å§‹...');
                                player.playVideoAt(0);
                            }
                            // For single video, let it play to the end
                        }
                    }
                } catch (e) {
                    console.warn('Progress check error:', e);
                }
            }, 1000);
        }

        function stopProgressChecker() {
            if (progressCheckerId) {
                clearInterval(progressCheckerId);
                progressCheckerId = null;
            }
        }

        // Watchdog to ensure playback doesn't stop unexpectedly
        let watchdogFailCount = 0;
        let lastWatchdogRecovery = 0;

        function startPlaybackWatchdog() {
            stopPlaybackWatchdog();
            watchdogFailCount = 0;

            playbackWatchdogId = setInterval(() => {
                // å¦‚æœä½¿ç”¨è€…æš«åœäº†è¨ˆæ™‚å™¨æˆ–æ’­æ”¾ï¼Œä¸è¦è‡ªå‹•æ¢å¾©
                if (timerPaused || userPaused || remainingSeconds <= 0) return;

                // å¦‚æœæ­£åœ¨æ¢å¾©ä¸­ï¼Œè·³é
                if (playerRecoveryInProgress) return;

                // Check if player exists and has methods
                if (!player || typeof player.getPlayerState !== 'function') {
                    watchdogFailCount++;
                    if (watchdogFailCount % 5 === 0) {
                        debugLog('ğŸ• Watchdog: æ’­æ”¾å™¨ä¸å¯ç”¨ #' + watchdogFailCount);
                    }

                    // Don't give up - just wait for player to reinitialize
                    if (watchdogFailCount > 3 && watchdogFailCount <= 10) {
                        updateStatus('ç­‰å¾…æ’­æ”¾å™¨é‡æ–°é€£ç·š...');
                    }
                    return;
                }

                try {
                    const playerState = player.getPlayerState();
                    const currentTime = player.getCurrentTime();
                    const now = Date.now();

                    // If player is not playing and timer is still active
                    if (playerState !== YT.PlayerState.PLAYING &&
                        playerState !== YT.PlayerState.BUFFERING) {

                        watchdogFailCount++;

                        // Check if video time hasn't changed (stuck)
                        if (Math.abs(currentTime - lastPlayingTime) < 1 || watchdogFailCount > 3) {
                            // é¿å…å¤ªé »ç¹åœ°å˜—è©¦æ¢å¾©ï¼ˆè‡³å°‘é–“éš” 10 ç§’ï¼‰
                            if (now - lastWatchdogRecovery < 10000) {
                                return;
                            }

                            debugLog('ğŸ• Watchdog: æ’­æ”¾åœæ»¯ state=' + playerState + ' fail=' + watchdogFailCount);

                            // Try different recovery methods based on state
                            if (playerState === YT.PlayerState.ENDED) {
                                // Video ended, try next video or restart playlist
                                const playlist = player.getPlaylist();
                                const currentIndex = player.getPlaylistIndex();

                                if (playlist && playlist.length > 0) {
                                    if (currentIndex < playlist.length - 1) {
                                        player.nextVideo();
                                    } else {
                                        player.playVideoAt(0);
                                    }
                                } else {
                                    // Single video, restart it
                                    const skipStart = parseInt(elements.skipStart.value) || 0;
                                    player.seekTo(skipStart, true);
                                    player.playVideo();
                                }
                                lastWatchdogRecovery = now;
                            } else if (playerState === YT.PlayerState.PAUSED ||
                                       playerState === YT.PlayerState.UNSTARTED ||
                                       playerState === YT.PlayerState.CUED ||
                                       playerState === -1) {

                                // å¦‚æœæ˜¯ UNSTARTED (-1) ç‹€æ…‹ä¸”å¤±æ•—è¶…é 6 æ¬¡ï¼Œç›´æ¥é‡æ–°è¼‰å…¥
                                // å› ç‚ºé€™ç¨®ç‹€æ…‹ä¸‹ playVideo() é€šå¸¸ç„¡æ•ˆ
                                if ((playerState === -1 || playerState === YT.PlayerState.UNSTARTED) &&
                                    watchdogFailCount > 6 && lastParsedUrl) {
                                    debugLog('ğŸ• Watchdog: UNSTARTED ç‹€æ…‹ï¼Œå¼·åˆ¶é‡æ–°è¼‰å…¥...');
                                    updateStatus('é‡æ–°è¼‰å…¥æ’­æ”¾æ¸…å–®...');

                                    // iOS éœ€è¦å…ˆéœéŸ³æ‰èƒ½è‡ªå‹•æ’­æ”¾
                                    if (player.mute) {
                                        player.mute();
                                    }

                                    if (lastParsedUrl.type === 'playlist') {
                                        player.loadPlaylist({
                                            list: lastParsedUrl.playlistId,
                                            listType: 'playlist',
                                            index: lastStartIndex,
                                            startSeconds: lastSkipStart
                                        });
                                    } else if (lastParsedUrl.videoId) {
                                        player.loadVideoById({
                                            videoId: lastParsedUrl.videoId,
                                            startSeconds: lastSkipStart
                                        });
                                    }

                                    // 3 ç§’å¾Œå˜—è©¦å–æ¶ˆéœéŸ³
                                    setTimeout(() => {
                                        if (player && player.unMute && player.getPlayerState) {
                                            const state = player.getPlayerState();
                                            if (state === YT.PlayerState.PLAYING || state === YT.PlayerState.BUFFERING) {
                                                player.unMute();
                                                debugLog('ğŸ”Š å–æ¶ˆéœéŸ³');
                                            }
                                        }
                                    }, 3000);

                                    watchdogFailCount = 0;
                                    lastWatchdogRecovery = now;
                                    return;
                                }

                                // Try to play
                                player.playVideo();
                                lastWatchdogRecovery = now;

                                // If still failing after many attempts, try reloading the video
                                if (watchdogFailCount > 12 && lastParsedUrl) {
                                    debugLog('ğŸ• Watchdog: å¤šæ¬¡å¤±æ•—ï¼Œé‡æ–°è¼‰å…¥...');
                                    updateStatus('é‡æ–°è¼‰å…¥ä¸­...');

                                    // Update lastStartIndex to current position if available
                                    try {
                                        const currentIndex = player.getPlaylistIndex();
                                        if (currentIndex >= 0) {
                                            lastStartIndex = currentIndex;
                                        }
                                    } catch (e) {}

                                    if (lastParsedUrl.type === 'playlist') {
                                        player.loadPlaylist({
                                            list: lastParsedUrl.playlistId,
                                            listType: 'playlist',
                                            index: lastStartIndex,
                                            startSeconds: lastSkipStart
                                        });
                                    } else if (lastParsedUrl.videoId) {
                                        player.loadVideoById({
                                            videoId: lastParsedUrl.videoId,
                                            startSeconds: lastSkipStart
                                        });
                                    }
                                    watchdogFailCount = 0;
                                    lastWatchdogRecovery = now;
                                }
                            }
                        }
                    } else {
                        // Player is working, reset fail count
                        watchdogFailCount = 0;
                        lastPlayingTime = currentTime;
                    }
                } catch (e) {
                    console.warn('Watchdog error:', e);
                    watchdogFailCount++;
                }
            }, 5000); // Check every 5 seconds (less aggressive)
        }

        function stopPlaybackWatchdog() {
            if (playbackWatchdogId) {
                clearInterval(playbackWatchdogId);
                playbackWatchdogId = null;
            }
        }

        // ============================
        // Sleep Timer Functions
        // ============================

        // Track last timer tick for health check
        let lastTimerTick = 0;

        function startSleepTimer() {
            const totalMins = parseInt(elements.totalMins.value) || 40;
            remainingSeconds = totalMins * 60;
            timerPaused = false;
            lastTimerTick = Date.now();

            elements.timerDisplay.classList.remove('hidden');
            elements.pauseTimerBtn.textContent = 'â¸ï¸ æš«åœ';
            updateCountdownDisplay();

            countdownInterval = setInterval(() => {
                if (!timerPaused) {
                    // Check for timer drift (Safari may throttle background timers)
                    const now = Date.now();
                    const elapsed = Math.floor((now - lastTimerTick) / 1000);

                    if (elapsed > 2) {
                        // Timer was throttled, adjust remaining time
                        debugLog('âš ï¸ è¨ˆæ™‚å™¨æ¼‚ç§»: ' + elapsed + 'ç§’');
                        remainingSeconds -= elapsed;
                    } else {
                        remainingSeconds--;
                    }

                    lastTimerTick = now;
                    updateCountdownDisplay();

                    // æ¯ 5 ç§’ä¿å­˜ä¸€æ¬¡ session
                    if (remainingSeconds % 5 === 0) {
                        saveSession();
                    }

                    if (remainingSeconds <= 0) {
                        stopEverything('timer_expired');
                    }
                }
            }, 1000);
        }

        function togglePauseTimer() {
            timerPaused = !timerPaused;
            userPaused = timerPaused;  // è¨­å®šä½¿ç”¨è€…æš«åœæ¨™è¨˜

            debugLog('â¯ï¸ æš«åœåˆ‡æ›: timerPaused=' + timerPaused + ' userPaused=' + userPaused);

            if (timerPaused) {
                // Pause video too
                if (player && player.pauseVideo) {
                    player.pauseVideo();
                }
                // åœæ­¢æ‰€æœ‰è‡ªå‹•æ¢å¾©æ©Ÿåˆ¶
                stopProgressChecker();
                elements.pauseTimerBtn.textContent = 'â–¶ï¸ ç¹¼çºŒ';
                updateStatus('å·²æš«åœ');
            } else {
                // Resume video
                userPaused = false;
                if (player && player.playVideo) {
                    player.playVideo();
                }
                startProgressChecker();
                elements.pauseTimerBtn.textContent = 'â¸ï¸ æš«åœ';
                updateStatus('æ’­æ”¾ä¸­...');
            }
        }

        function updateCountdownDisplay() {
            const mins = Math.floor(remainingSeconds / 60);
            const secs = remainingSeconds % 60;
            elements.timerCountdown.textContent =
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function stopEverything(reason = 'unknown') {
            // Log the call stack to identify what triggered the stop
            debugLog('â›” STOP! åŸå› : ' + reason);
            debugLog('ç‹€æ…‹: å‰©é¤˜=' + remainingSeconds + 's, session=' + sessionActive + ', playing=' + isPlaying);

            // Save progress before stopping
            saveCurrentProgress();

            if (player && player.stopVideo) {
                player.stopVideo();
            }

            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }

            stopProgressChecker();
            stopPlaybackWatchdog();
            isPlaying = false;
            timerPaused = false;
            userPaused = false;
            sessionActive = false;
            lastParsedUrl = null;
            playerRecoveryInProgress = false;
            bufferFailCount = 0;
            watchdogFailCount = 0;

            // æ¸…é™¤ localStorage ä¸­çš„ session
            clearSession();

            // Disable NoSleep
            disableNoSleep();

            elements.timerDisplay.classList.add('hidden');
            elements.startBtn.textContent = 'ğŸµ é–‹å§‹æ’­æ”¾';
            elements.startBtn.classList.remove('bg-slate-700');
            elements.startBtn.classList.add('bg-accent');
            updateStatus('æ’­æ”¾å·²åœæ­¢');
        }

        // ============================
        // UI Helper Functions
        // ============================

        function updateStatus(text) {
            elements.statusText.textContent = text;
        }

        function validateInputs() {
            const url = elements.youtubeUrl.value.trim();
            const parsed = parseYouTubeUrl(url);

            if (!parsed) {
                alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„ YouTube ç¶²å€');
                elements.youtubeUrl.focus();
                return false;
            }
            return true;
        }

        // ============================
        // Main Start Function
        // ============================

        function startPlayback() {
            if (!validateInputs()) return;

            const url = elements.youtubeUrl.value.trim();
            const parsed = parseYouTubeUrl(url);
            const skipStart = parseInt(elements.skipStart.value) || 0;
            // User inputs 1 for first episode, convert to 0-based index
            const startIndex = Math.max(0, (parseInt(elements.startIndex.value) || 1) - 1);

            saveSettings();

            // Enable NoSleep to keep screen on
            enableNoSleep();

            // Save session state for recovery
            sessionActive = true;
            lastParsedUrl = parsed;
            lastStartIndex = startIndex;
            lastSkipStart = skipStart;

            if (parsed.type === 'playlist') {
                // Load as playlist with selected index
                player.loadPlaylist({
                    list: parsed.playlistId,
                    listType: 'playlist',
                    index: startIndex,
                    startSeconds: skipStart
                });
                updateStatus(`è¼‰å…¥æ’­æ”¾æ¸…å–®ç¬¬ ${startIndex + 1} é›†...`);
            } else {
                // Load single video
                player.loadVideoById({
                    videoId: parsed.videoId,
                    startSeconds: skipStart
                });
                updateStatus('è¼‰å…¥å½±ç‰‡ä¸­...');
            }

            // è¨ˆæ™‚å™¨æœƒåœ¨å½±ç‰‡çœŸæ­£é–‹å§‹æ’­æ”¾å¾Œæ‰å•Ÿå‹• (åœ¨ onPlayerStateChange ä¸­)
            // startSleepTimer(); -- ç§»åˆ° PLAYING ç‹€æ…‹æ™‚æ‰å•Ÿå‹•
            startPlaybackWatchdog();
            debugLog('â–¶ï¸ è¼‰å…¥å½±ç‰‡ä¸­ï¼Œç­‰å¾…ç·©è¡... å®šæ™‚=' + elements.totalMins.value + 'åˆ†é˜');

            elements.startBtn.textContent = 'â¹ï¸ åœæ­¢æ’­æ”¾';
            elements.startBtn.classList.remove('bg-accent');
            elements.startBtn.classList.add('bg-slate-700');
        }

        // ============================
        // Event Listeners
        // ============================

        elements.startBtn.addEventListener('click', (e) => {
            // è¨˜éŒ„é»æ“Šäº‹ä»¶çš„è©³ç´°è³‡è¨Š
            debugLog('ğŸ–±ï¸ é–‹å§‹æŒ‰éˆ•è¢«é»æ“Š! isTrusted=' + e.isTrusted + ' type=' + e.type);

            // Check if currently playing OR if countdown timer is active
            if (isPlaying || countdownInterval) {
                // åŠ å…¥ç¢ºèªï¼Œé˜²æ­¢èª¤è§¸
                if (e.isTrusted) {
                    // çœŸå¯¦çš„ä½¿ç”¨è€…é»æ“Šï¼Œä½†é‚„æ˜¯è¦ç¢ºèª
                    debugLog('âš ï¸ æº–å‚™åœæ­¢æ’­æ”¾...');
                    stopEverything('start_btn_clicked');
                } else {
                    // ç¨‹å¼è§¸ç™¼çš„é»æ“Šï¼Œå¿½ç•¥
                    debugLog('ğŸš« å¿½ç•¥éä½¿ç”¨è€…è§¸ç™¼çš„é»æ“Š');
                }
            } else {
                startPlayback();
            }
        });

        elements.pauseTimerBtn.addEventListener('click', (e) => {
            debugLog('ğŸ–±ï¸ æš«åœæŒ‰éˆ•è¢«é»æ“Š! isTrusted=' + e.isTrusted);
            togglePauseTimer();
        });

        elements.stopTimerBtn.addEventListener('click', (e) => {
            debugLog('ğŸ–±ï¸ åœæ­¢æŒ‰éˆ•è¢«é»æ“Š! isTrusted=' + e.isTrusted);
            stopEverything('stop_btn_clicked');
        });
        elements.clearUrlBtn.addEventListener('click', () => {
            elements.youtubeUrl.value = '';
            elements.youtubeUrl.focus();
        });

        document.getElementById('clearDebugBtn').addEventListener('click', () => {
            document.getElementById('debugLog').textContent = '';
            localStorage.removeItem('sleepyyt_debug');
        });

        document.getElementById('copyDebugBtn').addEventListener('click', () => {
            const logText = document.getElementById('debugLog').textContent;
            navigator.clipboard.writeText(logText).then(() => {
                const btn = document.getElementById('copyDebugBtn');
                btn.textContent = 'âœ… å·²è¤‡è£½';
                setTimeout(() => { btn.textContent = 'ğŸ“‹ è¤‡è£½'; }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = logText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                const btn = document.getElementById('copyDebugBtn');
                btn.textContent = 'âœ… å·²è¤‡è£½';
                setTimeout(() => { btn.textContent = 'ğŸ“‹ è¤‡è£½'; }, 2000);
            });
        });

        document.querySelectorAll('.time-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const adjust = parseInt(btn.dataset.adjust);
                const current = parseInt(elements.totalMins.value) || 40;
                const newValue = Math.max(5, Math.min(180, current + adjust));
                elements.totalMins.value = newValue;
                saveSettings();
            });
        });

        document.querySelectorAll('.quick-time').forEach(btn => {
            btn.addEventListener('click', () => {
                elements.totalMins.value = btn.dataset.mins;
                saveSettings();
            });
        });

        [elements.youtubeUrl, elements.skipStart, elements.skipEnd, elements.startIndex, elements.totalMins].forEach(input => {
            input.addEventListener('change', saveSettings);
        });

        // ============================
        // Initialization
        // ============================

        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            loadDebugLogs();
            debugLog('ğŸ”„ é é¢è¼‰å…¥');
        });

        // Load YouTube IFrame API
        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // Prevent accidental navigation and log unload events
        window.addEventListener('beforeunload', (e) => {
            debugLog('âš ï¸ beforeunload è§¸ç™¼!');
            if (isPlaying || countdownInterval) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        window.addEventListener('unload', () => {
            debugLog('âš ï¸ unload è§¸ç™¼!');
        });

        window.addEventListener('pagehide', (e) => {
            debugLog('âš ï¸ pagehide è§¸ç™¼! persisted=' + e.persisted);
        });

        // Catch all errors
        window.addEventListener('error', (e) => {
            debugLog('âŒ éŒ¯èª¤: ' + e.message);
        });

        window.addEventListener('unhandledrejection', (e) => {
            debugLog('âŒ PromiseéŒ¯èª¤: ' + e.reason);
        });

        // ============================
        // iOS/Safari Specific Handling
        // ============================

        // Handle page visibility change (iOS Safari may pause when switching apps)
        document.addEventListener('visibilitychange', () => {
            console.log('Visibility changed:', document.visibilityState, 'sessionActive:', sessionActive);

            if (document.visibilityState === 'visible' && sessionActive && remainingSeconds > 0) {
                // Page became visible again, check if player needs recovery
                setTimeout(() => {
                    if (!player) {
                        console.log('Player lost, will recover on re-init');
                        return;
                    }

                    try {
                        const playerState = player.getPlayerState();
                        console.log('Player state on visibility:', playerState);

                        // If not playing, try to resume
                        if (playerState !== YT.PlayerState.PLAYING &&
                            playerState !== YT.PlayerState.BUFFERING &&
                            !timerPaused) {
                            console.log('Resuming playback after visibility change...');
                            player.playVideo();
                        }
                    } catch (e) {
                        console.warn('Error checking player state:', e);
                        // Player might be broken, try recovery
                        if (lastParsedUrl) {
                            updateStatus('é‡æ–°è¼‰å…¥æ’­æ”¾å™¨...');
                            if (lastParsedUrl.type === 'playlist') {
                                player.loadPlaylist({
                                    list: lastParsedUrl.playlistId,
                                    listType: 'playlist',
                                    index: lastStartIndex,
                                    startSeconds: lastSkipStart
                                });
                            } else if (lastParsedUrl.videoId) {
                                player.loadVideoById({
                                    videoId: lastParsedUrl.videoId,
                                    startSeconds: lastSkipStart
                                });
                            }
                        }
                    }
                }, 500);
            }
        });

        // Handle page freeze/resume (iOS Safari specific)
        document.addEventListener('freeze', () => {
            console.log('Page frozen by browser');
        });

        document.addEventListener('resume', () => {
            console.log('Page resumed, sessionActive:', sessionActive);
            if (sessionActive && remainingSeconds > 0 && !timerPaused) {
                setTimeout(() => {
                    if (player && player.playVideo) {
                        console.log('Attempting to resume after page resume...');
                        player.playVideo();
                    }
                }, 1000);
            }
        });

        // Periodic audio context keep-alive for iOS
        let audioKeepAliveInterval = null;

        function startAudioKeepAlive() {
            if (audioKeepAliveInterval) return;

            // Create a silent audio context to keep audio alive
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    const audioCtx = new AudioContext();

                    audioKeepAliveInterval = setInterval(() => {
                        if (sessionActive && remainingSeconds > 0) {
                            // Create a very short silent sound
                            const oscillator = audioCtx.createOscillator();
                            const gainNode = audioCtx.createGain();
                            gainNode.gain.value = 0.001; // Nearly silent
                            oscillator.connect(gainNode);
                            gainNode.connect(audioCtx.destination);
                            oscillator.start();
                            oscillator.stop(audioCtx.currentTime + 0.001);
                        }
                    }, 25000); // Every 25 seconds

                    console.log('Audio keep-alive started');
                }
            } catch (e) {
                console.warn('Could not start audio keep-alive:', e);
            }
        }

        function stopAudioKeepAlive() {
            if (audioKeepAliveInterval) {
                clearInterval(audioKeepAliveInterval);
                audioKeepAliveInterval = null;
                console.log('Audio keep-alive stopped');
            }
        }

        // Start audio keep-alive when playback starts
        const originalStartPlayback = startPlayback;
        startPlayback = function() {
            originalStartPlayback();
            startAudioKeepAlive();
        };

        const originalStopEverything = stopEverything;
        stopEverything = function(reason) {
            stopAudioKeepAlive();
            originalStopEverything(reason || 'wrapper_call');
        };
    </script>
</body>
</html>
